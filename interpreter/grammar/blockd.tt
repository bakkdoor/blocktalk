grammar Blockd do
  rule blockd_programm do
    (expression / comment)*
  end

  # comments start with '#' and end at the end of a line, as in ruby
  rule comment do
    '#' (!'\n' . )*
  end

  # expressions start here

  # an expression is one of the following:
  # assignment, method_call, literal or subexpression
  rule expression do
    (method_call / assignment / literal / subexpression) ws* newline?
  end

  # a subexpression is an expression surrounded by parenthesis for grouping.
  # e.g.: (gets to_i) + 3
  rule subexpression do
    '(' ws* expression ws* ')'
  end

  # an assignment typically looks like this:
  # identifier = value (value is either an (sub)expression, an identifier or a literal
  rule assignment do
    identifier ws* '=' ws* (expression / subexpression / identifier / literal)
  end

  # a method_call is characterized by a receiver, a message and optional parameters:
  # e.g.: receiver message
  #       receiver message: param_value
  #       receiver message: param1_value param2: param2_value ...
  rule method_call do
    receiver:(message_receiver) ' ' (operator_message / message_with_params / message_without_params) (' ' passed_block:(block_literal))?
  end

  # a message receiver is one of the following:
  # - message_without_params, e.g.: "42" to_i to_f # -> 42.0
  # - literals, e.g. 123, 123.456, [1,2,3], {:a => 1, :b => 2}, "hello world", ?C etc.
  # subexpressions, e.g. (3 + 4), ("foo" to_sym) etc.
  rule message_receiver do
    message_without_params / (literal / identifier) / subexpression
  end

  # a message with parameters passed to it should look like this:
  # receiver message: param1_value param2: param2_value param3: param3_value etc.
  rule message_with_params do
    message:(message_name) params:(message_params)
  end

  # a message without parameters passed to it looks like this:
  # receiver message
  rule message_without_params do
    message:(message_name) !message_params
  end

  rule operator_message do
    operator_name:(operator) ' ' param_value !message_params
  end

  # message parameters look like this:
  # first_param param2_name: param2_value param3_name: param3_value
  # but the additional parameters beyond the first one are optional.
  rule message_params do
    first_param:(first_param) rest_params:(ws+ param)*
  end

  # the first_param is the one that gets passed to a message in the first position.
  # it's param_name is the message_name, so to speak.
  rule first_param do
    ':' ' ' first_param_value:(param_value)
  end

  rule param do
    param_name ' ' param_value:(param_value)
  end

  rule param_name do
    identifier ':'
  end

  rule param_value do
    literal / identifier / subexpression
  end

  # literals

  rule literal do
    string_literal / symbol_literal / int_literal / float_literal / char_literal / array_literal / hash_literal / block_literal
  end

  rule string_literal do
    '"' (!'"' .)* '"'
  end

  rule symbol_literal do
    ':' symbol_name:(!':' identifier)
  end

  rule int_literal do
    (sign? non_zero_digit digit*) / [0]
  end

  rule float_literal do
    sign? digit+ '.' digit+
  end

  rule char_literal do
    '?' [a-zA-Z0-9_]
  end

  rule array_literal do
    '[' ws* (literal / identifier)? ws* rest_items:(',' ws* item:(literal / identifier))* ws* ']'
  end

  rule hash_literal do
    '{' ws* '}' /
      '{' ws* hash_entry ws* rest_pairs:(',' ws* pair:(hash_entry))*  ws* '}'
  end

  rule hash_entry do
    (literal / identifier) ws* '=>' ws* (literal / identifier)
  end

  rule block_literal do
    ('{' ws* (!hash_entry ws* block_params ws*)* block_body ws* '}') /
      (do_keyword ws* (!hash_entry ws* block_params ws*)* block_body ws* end_keyword)
  end

  rule block_body do
    expression*
  end

  rule block_params do
    '|' block_param+ '|'
  end

  rule block_param do
    ws* identifier (ws*) / (ws+ identifier)
  end


  # other rules

  rule identifier do
    ('@' / '@@')? [a-zA-Z]+ [a-zA-Z0-9_]*
  end

  rule message_name do
    [a-zA-Z]+ [a-zA-Z0-9_]* ('?' / '!' / '=')?
  end

  rule operator do
    ('=' operator_symbol+) / (operator_symbol '=' operator_symbol*) / operator_symbol+
  end

  rule operator_symbol do
    ('<=' / '>='/ '<' / '>' / '==' / '!=' / '+=' / '-=' / '&' / '.' / '+' / '-' / '/' / '*' / '|')
  end

  rule ws do
    [\n\s\t]+
  end

  rule spaces do
    [\s\t]+
  end

  rule line_breaking_ws do
    [\n\s\t]+
  end

  rule newline do
    [\n]+
  end

  rule do_keyword do
    'do' ![a-zA-Z0-9_] &ws
  end

  rule end_keyword do
    'end' ![a-zA-Z0-9_]
  end

  rule non_zero_digit do
    [1-9]
  end

  rule digit do
    [0-9]
  end

  rule sign do
    ('+' / '-')
  end
end
